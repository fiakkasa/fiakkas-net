@page "/weather"
@attribute [StreamRendering]
@inject ILogger<Weather> _logger
@implements IDisposable

<UniversalTitle Title="Weather">
    <button type="button" class="btn btn-outline-primary rounded-5 p-0 px-1" title="Refresh" disabled="@_loading"
        @onclick="SetData">
        <i class="bi bi-arrow-clockwise"></i>
    </button>
</UniversalTitle>

<ContentFlow IsLoading="@_loading" HasError="@_hasError" HasContent="@(_result is { Length: > 0 })">
    <div class="d-none d-md-block">
        <table class="table">
            <thead>
                <tr>
                    <th>Date</th>
                    <th>Temp. (C)</th>
                    <th>Temp. (F)</th>
                    <th>Summary</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var forecast in _result)
                {
                    <tr>
                        <td>@forecast.Date.ToShortDateString()</td>
                        <td>@forecast.TemperatureC</td>
                        <td>@forecast.TemperatureF</td>
                        <td>@forecast.Summary</td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
    <div class="d-block d-md-none">
        <ul class="list-group">
            @foreach (var forecast in _result)
            {
                <li class="list-group-item">
                    <div><strong>Date:</strong> @forecast.Date.ToShortDateString()</div>
                    <div><strong>Temp. (C):</strong> @forecast.TemperatureC</div>
                    <div><strong>Temp. (F):</strong> @forecast.TemperatureF</div>
                    <div><strong>Summary:</strong> @forecast.Summary</div>
                </li>
            }
        </ul>
    </div>
</ContentFlow>

@code {
    private bool _loading = true;
    private bool _hasError = false;
    private WeatherForecast[] _result = [];
    private readonly CancellationTokenSource _cancellationTokenSource = new();
    private readonly DateOnly _startDate = DateOnly.FromDateTime(DateTime.Now);

    private static readonly string[] _summaries = [ "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot",
"Sweltering",
"Scorching" ];

    protected override async Task OnInitializedAsync() => await SetData();

    private async Task SetData()
    {
        try
        {
            _loading = true;
            _hasError = false;
            _result = [];

            StateHasChanged();

            await Task.Delay(500, _cancellationTokenSource.Token);

            _result = Enumerable.Range(1, Random.Shared.Next(5, 100)).Select(index => new WeatherForecast
                {
                    Date = _startDate.AddDays(index),
                    TemperatureC = Random.Shared.Next(-20, 55),
                    Summary = _summaries[Random.Shared.Next(_summaries.Length)]
                }).ToArray();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to retrieve data with message: {Message}", ex.Message);
            _result = [];
            _hasError = true;
        }

        _loading = false;

        StateHasChanged();
    }

    public void Dispose()
    {
        _cancellationTokenSource.Cancel();
        _cancellationTokenSource.Dispose();
    }

    private record WeatherForecast
    {
        public DateOnly Date { get; set; }
        public int TemperatureC { get; set; }
        public string? Summary { get; set; }
        public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
    }
}
